<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <title>Lista 3 - Problema 1</title>
  <script src="https://d3js.org/d3.v4.min.js"></script>
</head>

<style>
  
  div.tooltip {
    position: absolute;
    text-align: center;
    width: 90px;
    height: 30px;
    padding: 2px;
    font: 12px Verdana;
    background: #a1a1ff;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }

  d3-tip {
    line-height: 1;
    color: black;
  }   
</style>

<body>
  <h4>Selecione o n√∫mero de vizinhos: </h4>
  <svg width="960" height="600"></svg>
</body>

<script>

  var n = 2; //Nearest neighbour
  var data = []; //All nodes
  var all_links =[]; //All links and euclidian distance
  var dataLink = []; //Top N links by nodes

  var svg = d3.select("svg"),
      width = +svg.attr("width"),
      height = +svg.attr("height");

  var options = [2, 3, 7, 8, 9, 10, 11, 12, 13, 14, 15];

  d3.select("h4")
    .append("select")
    .on('change',function(){updateGraph(n, parseInt(this.value));})
    .selectAll("option")
      .data(options)
      .enter()
      .append("option")
      .text(String);

  var color = d3.scaleOrdinal(d3.schemeCategory20);

  var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("forceX", d3.forceX(600).strength(0.06))
    .force("forceY", d3.forceY(300).strength(0.06));

  var tooltip = d3.select("h4").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0); 

  //Read json (dataset)
  d3.json("iris.json", function(error, nodes) {
    if (error) throw error;

    data = getNodes(nodes);
    all_links = euclidenDistanceCalculate(nodes);
   // dataLink = kNearestNeighborsLinks(n);

    //var numVizinhos = new Uint8Array(data.length);
    for(i = 0; i < data.length; i++){
      var neighbors = 0;
      for(j = 0; j < all_links.length && neighbors < n; j++){
        if(all_links[j].source == i ){
          neighbors += 1;
          dataLink.push(all_links[j]);
        }
      }
    }

    var dataset = {"nodes":nodes, "links":dataLink}

    var node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(dataset.nodes)
        .enter()
        .append("circle")
        .attr("r", 6)
        .attr("fill", function(d){ return colorScale(d.species);})
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

    node.on("mouseover", function(d) { 
         tooltip.transition()
           .style("opacity", .9);
         tooltip.html(d.species+ "<br/>id: " + d.index)
           .style("left", 880 + "px")
           .style("top", "0px")
           .style("margin-top", "15px");})

    var link = svg.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(dataset.links)
      .enter().append("line")
      .attr("stroke-width", function(d) { return 1; });

    simulation
        .nodes(dataset.nodes)
        .on("tick", ticked);

    simulation
        .force("link")
        .links(dataset.links);

    function ticked() {
      link
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      node
          .attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });
    }
  });

  function getNodes(nodes){
    var result = [];

    for (i = 0; i < nodes.length; i++){
      result.push({"id":i, "species":color(nodes.species)});
    }

    return result;
  }
  //Get k nearest neighbors for all nodes on dataset
  function kNearestNeighborsLinks(n){
      var result = [];
      //var numVizinhos = new Uint8Array(data.length);
      //debugger;
      for(i = 0; i < data.length; i++){
        var neighbors = 0;

        for(j = 0; j < all_links.length && neighbors < n; j++){
          if(all_links[j].source.index != undefined){
            if(all_links[j].source.index == i ){
              neighbors += 1;
              result.push({"source":all_links[j].source.index,
                           "target":all_links[j].target.index,
                           "value":all_links[j].value});
              console.log("source - " +all_links[j].source.index + " target - " + all_links[j].target.index);
            }
          } else{
            if(all_links[j].source == i ){
              neighbors += 1;
              console.log("source - " +all_links[j].source + " target - " + all_links[j].target);
              result.push(all_links[j]);
            }
          }
        }
      }
      //debugger;
    
      return result;
  }

  //Calculate Euc. Distance and return all links 
  function euclidenDistanceCalculate(nodes){
    var result = [];

    for(var i=0; i < nodes.length; i++){          
      for(var j = 0; j < nodes.length ; j++){
          if (i == j){
            continue;
          }

          var a1, a2 , a3 , a4 ;

          a1 = nodes[i].sepal_length - nodes[j].sepal_length;

          a2 = nodes[i].sepal_width - nodes[j].sepal_width;

          a3 = nodes[i].petal_length - nodes[j].petal_length;

          a4 = nodes[i].petal_width - nodes[j].petal_width;

          a1_diff = Math.pow(a1, 2);
          a2_diff = Math.pow(a2, 2);
          a3_diff = Math.pow(a3, 2);
          a4_diff = Math.pow(a4, 2);

          sum = a1_diff + a2_diff + a3_diff + a4_diff;

          result.push({"source": i , "target": j, "value": Math.sqrt(sum).toFixed(5)});
          //console.log("source: " + i + " target: " + j + " value: " + Math.sqrt(sum));
      }
    }

    //Order result by distance value
    result = result.sort(function(a, b){
        return a.value - b.value;
    });
    //debugger;
    return result;
  }

  function colorScale(specie){
      if(specie === "setosa"){
          return "blue";
      }else{
          return "green";
      }
  }

  function updateGraph(n_curr, n_att){
    dataLink = kNearestNeighborsLinks(n_att);// Get N neighbors for all nodes
    debugger;
    //console.log(dataLink.length);
    var link = svg.select(".links").selectAll("line").data(dataLink);
    //var node  = svg.select(".nodes").selectAll("circle").data(data);
      link.exit().remove();
      link = link.enter()
                .append("line")
                .attr("stroke-width", function(d) { return 1; })
                .merge(link);

      //node.exit().remove();
      //node = node.enter()
                //.append("circle")
                //.merge(node);     
 

      // Update and restart the simulation.
     // simulation.nodes(data);
      simulation.force("link")
        .links(dataLink);      
      simulation.alpha(1).restart();

    n = n_att; //Update n 
  }

  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
</script>