<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <title>Lista 3 - Problema 1</title>
  <script src="https://d3js.org/d3.v4.min.js"></script>
</head>

<style>
  .links line {
    stroke: #999;
    stroke-opacity: 0.6;
  }

  .nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
  }

  div.tooltip {
    position: absolute;
    text-align: center;
    width: 90px;
    height: 30px;
    padding: 2px;
    font: 12px Verdana;
    background: #a1a1ff;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }

  d3-tip {
    line-height: 1;
    color: black;
  }   
</style>

<body>
  <h4>Selecione o n√∫mero de vizinhos: </h4>
  <svg width="960" height="600"></svg>
</body>

<script>

  var n = 2; //Nearest neighbour
  var data = []; //All nodes
  var all_links =[]; //All links and euclidian distance
  var dataLink = []; //Top N links by nodes

  var svg = d3.select("svg"),
      width = +svg.attr("width"),
      height = +svg.attr("height");

  var options = [2, 3, 7, 8, 9, 10, 11, 12, 13, 14, 15];

  d3.select("h4")
    .append("select")
    .on('change',function(){updateGraph(n, parseInt(this.value));})
    .selectAll("option")
      .data(options)
      .enter()
      .append("option")
      .text(String);

  var color = d3.scaleOrdinal(d3.schemeCategory20);

  var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.index; }).distance(25))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(width / 2, height / 2));

  var tooltip = d3.select("h4").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0); 

  //Read json (dataset)
  d3.json("iris.json", function(error, nodes) {
    if (error) throw error;

    data = nodes;
    all_links = euclidenDistanceCalculate(nodes);
    dataLink = kNearestNeighborsLinks(n);

    var node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(nodes)
        .enter()
        .append("circle")
        .attr("r", 6)
        .attr("fill", function(d){ return colorScale(d.species);})
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

    node.on("mouseover", function(d) { 
         tooltip.transition()
           .style("opacity", .9);
         tooltip.html(d.species+ "<br/>id: " + d.index)
           .style("left", 880 + "px")
           .style("top", "0px")
           .style("margin-top", "15px");})

    var link = svg.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(dataLink)
      .enter().append("line")
      .attr("stroke-width", function(d) { return 1; });

    simulation
        .nodes(nodes)
        .on("tick", ticked);

    simulation
        .force("link")
        .links(dataLink);

    function ticked() {
      link
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      node
          .attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });
    }
  });
  
  //Get k nearest neighbors for all nodes on dataset
  function kNearestNeighborsLinks(n){
      var result = [];
      var numVizinhos = new Uint8Array(data.length);
      debugger;
      for (var i = 0; i < all_links.length; i++) {
        if(numVizinhos[all_links[i].source] < n){
          numVizinhos[all_links[i].source] += 1;
          console.log(all_links[i].source + ' -> ' + all_links[i].target);
          result.push(all_links[i]);            
        }
      }
      console.log(numVizinhos);
      return result;
  }

  //Calculate Euc. Distance and return all links 
  function euclidenDistanceCalculate(nodes){
    var result = [];

    for(var i=0; i < nodes.length; i++){          
      for(var j = 0; j < nodes.length ; j++){
          if (i == j){
            continue;
          }

          var a1, a2 , a3 , a4 ;

          a1 = nodes[i].sepal_length - nodes[j].sepal_length;

          a2 = nodes[i].sepal_width - nodes[j].sepal_width;

          a3 = nodes[i].petal_length - nodes[j].petal_length;

          a4 = nodes[i].petal_width - nodes[j].petal_width;

          a1_diff = Math.pow(a1, 2);
          a2_diff = Math.pow(a2, 2);
          a3_diff = Math.pow(a3, 2);
          a4_diff = Math.pow(a4, 2);

          sum = a1_diff + a2_diff + a3_diff + a4_diff;

          result.push({"source": i , "target": j, "value": Math.sqrt(sum)});
          //console.log("source: " + i + " target: " + j + " value: " + Math.sqrt(sum));
      }
    }

    //Order result by distance value
    result = result.sort(function(a, b){
        return a.value - b.value;
    });
    debugger;
    return result;
  }

  function colorScale(specie){
      if(specie === "setosa"){
          return "blue";
      }else{
          return "green";
      }
  }

  function updateGraph(n_curr, n_att){
    dataLink = kNearestNeighborsLinks(n_att);// Get N neighbors for all nodes

    if(n_att > n_curr){ //Add new links
      svg.selectAll("line")
        .data(dataLink)
        .enter().append("line")
        .attr("stroke-width", function(d) { return 1; });
    }else if(n_att < n_curr){ //Remove links
      svg
        .selectAll("line")
        .data(dataLink)
        .exit().remove();
    }

    //Update links
    svg.selectAll("line")
        .data(dataLink)
        .append("line")
        .attr("stroke-width", function(d) { return 1; });

    simulation
      .force("link")
      .links(dataLink);

    n = n_att; //Update n 
  }

  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
</script>